<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tensor matrix elements · AngularMomentumAlgebra</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AngularMomentumAlgebra</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../definitions/">Definitions</a></li><li><a class="tocitem" href="../common/">Common routines</a></li><li><a class="tocitem" href="../orbitals/">Orbitals</a></li><li><span class="tocitem">Tensors</span><ul><li><a class="tocitem" href="../tensors/">General tensors</a></li><li><a class="tocitem" href="../tensor_dsl/">Tensor DSL</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Various tensors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../angular_momenta/">Angular momenta</a></li><li><a class="tocitem" href="../spherical_tensors/">Spherical tensors</a></li><li><a class="tocitem" href="../gradients/">Gradients</a></li><li><a class="tocitem" href="../multipole_expansions/">Multipole expansions</a></li><li><a class="tocitem" href="../coulomb/">Coulomb interaction</a></li></ul></li><li class="is-active"><a class="tocitem" href>Tensor matrix elements</a><ul class="internal"><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Tensor-acts-on-entire-system"><span>Tensor acts on entire system</span></a></li><li><a class="tocitem" href="#Tensor-acts-on-subsystems"><span>Tensor acts on subsystems</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../energy_expressions/">Energy expressions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tensors</a></li><li class="is-active"><a href>Tensor matrix elements</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tensor matrix elements</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/master/docs/src/tensor_matrix_elements.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tensor-matrix-elements"><a class="docs-heading-anchor" href="#Tensor-matrix-elements">Tensor matrix elements</a><a id="Tensor-matrix-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-matrix-elements" title="Permalink"></a></h1><p>The matrix element of any irreducible tensor operator of rank <span>$k$</span> is defined as</p><p class="math-container">\[\begin{equation}
\tag{V13.1.1}
\matrixel{n&#39;j&#39;m&#39;}{\tensor{T}^{(k)}_q}{njm} \defd
\int\diff{\tau}
\conj{\Psi}_{n&#39;j&#39;m&#39;}
\tensor{T}^{(k)}_q
\Psi_{njm}.
\end{equation}\]</p><p>For simple quantum systems, it is most easily evaluated using <a href="#wigner_eckart">the Wigner–Eckart theorem</a>; however, in most cases, the quantum system and/or the tensor is composed of multiple parts, which complicates the situation. The table below shows the most common cases:</p><table><tr><th style="text-align: right">Basis \ Tensor</th><th style="text-align: right">Acts on entire system</th><th style="text-align: right">Acts on subsystems</th></tr><tr><td style="text-align: right"><strong>Uncoupled</strong></td><td style="text-align: right">Transform to coupled basis: <span>$\eqref{eqn:coupling}$</span></td><td style="text-align: right"><a href="#Evaluation-in-subspace">Evaluation in subspace</a></td></tr><tr><td style="text-align: right"><strong>Coupled</strong></td><td style="text-align: right">Wigner–Eckart: <span>$\eqref{eqn:wigner-eckart}$</span></td><td style="text-align: right">Uncoupling: <span>$\eqref{eqn:uncoupling}$</span></td></tr></table><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><p>There are two interfaces provided for computation of matrix element of tensor operators:</p><ul><li>A low-level interface <code>matrix_element((γj′, m′), 𝐓ᵏq, (γj′, m′))</code> (and friends), where <code>γj′</code>, <code>m′</code>, <code>γj′</code>, and <code>m′</code> are quantum numbers.</li><li>A high-level interface <code>dot(a, 𝐓ᵏq, b)</code>, where <code>a</code> and <code>b</code> are <code>SpinOrbital</code>s from <a href="https://github.com/JuliaAtoms/AtomicLevels.jl.git">AtomicLevels.jl</a>. The high-level interface dispatches as appropriate to the low-level interface, depending on whether <code>a</code> and <code>b</code> are expressed in the coupled basis or not, and which part of the quantum system <code>𝐓ᵏq</code> acts on.</li></ul><h3 id="High-level-interface"><a class="docs-heading-anchor" href="#High-level-interface">High-level interface</a><a id="High-level-interface-1"></a><a class="docs-heading-anchor-permalink" href="#High-level-interface" title="Permalink"></a></h3><p>There are two main functions in the high-level interface:</p><ul><li><code>dot(a, 𝐓ᵏq, b)</code> for one-body interactions</li><li><code>dot((a,b), 𝐓ᵏq, (c,d))</code> for two-body interactions (e.g. <a href="../coulomb/#Coulomb-interaction">Coulomb interaction</a>).</li></ul><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Tuple{SpinOrbital, TensorComponent, SpinOrbital}" href="#LinearAlgebra.dot-Tuple{SpinOrbital, TensorComponent, SpinOrbital}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot(a::SpinOrbital,
    𝐓ᵏq::Union{TensorComponent,TensorScalarProduct},
    b::SpinOrbital)</code></pre><p>Compute the matrix element <code>⟨a|𝐓ᵏq|b⟩</code> in the basis of spin-orbitals, dispatching to the correct low-level function <code>matrix_element</code>, depending on the value of <code>system(𝐓ᵏq)</code>.</p><p><strong>Examples with coupled orbitals</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a,b,c,d = (SpinOrbital(ro&quot;2p&quot;, half(3)),
                  SpinOrbital(ro&quot;2p&quot;, half(1)),
                  SpinOrbital(ro&quot;2s&quot;, half(1)),
                  SpinOrbital(ro&quot;3d&quot;, half(3)))
(2p(3/2), 2p(1/2), 2s(1/2), 3d(3/2))

julia&gt; 𝐋, 𝐒, 𝐉 = OrbitalAngularMomentum(), SpinAngularMomentum(), TotalAngularMomentum()
(𝐋̂⁽¹⁾, 𝐒̂⁽¹⁾, 𝐉̂⁽¹⁾)

julia&gt; 𝐋², 𝐒², 𝐉² = 𝐋⋅𝐋, 𝐒⋅𝐒, 𝐉⋅𝐉
((𝐋̂⁽¹⁾⋅𝐋̂⁽¹⁾), (𝐒̂⁽¹⁾⋅𝐒̂⁽¹⁾), (𝐉̂⁽¹⁾⋅𝐉̂⁽¹⁾))

julia&gt; dot(a, cartesian_tensor_component(𝐉, :x), b),
           1/2*√((3/2+1/2+1)*(3/2-1/2)) # 1/2√((J+M+1)*(J-M))
(0.8660254037844386, 0.8660254037844386)

julia&gt; dot(a, cartesian_tensor_component(𝐉, :z), a), a.m[1]
(1.5, 3/2)

julia&gt; dot(a, TensorComponent(𝐋, 0), a)
0.9999999999999999

julia&gt; dot(c, cartesian_tensor_component(Gradient(), :x), a)
- 0.408248(∂ᵣ + 2/r)

julia&gt; dot(c, cartesian_tensor_component(SphericalTensor(1), :x), a)
-0.40824829046386296

julia&gt; orbitals = rsos&quot;2[p]&quot;
6-element Array{SpinOrbital{RelativisticOrbital{Int64},Tuple{Half{Int64}}},1}:
 2p-(-1/2)
 2p-(1/2)
 2p(-3/2)
 2p(-1/2)
 2p(1/2)
 2p(3/2)

julia&gt; map(o -&gt; dot(o, 𝐉², o), orbitals)
6-element Array{Float64,1}:
 0.7499999999999998
 0.7499999999999998
 3.7500000000000004
 3.7500000000000004
 3.7500000000000004
 3.7500000000000004

julia&gt; 1/2*(1/2+1),3/2*(3/2+1) # J(J+1)
(0.75, 3.75)

julia&gt; dot(a, 𝐋², a), 1*(1+1)
(2.0, 2)

julia&gt; dot(d, 𝐋², d), 2*(2+1)
(5.999999999999999, 6)

julia&gt; dot(a, 𝐒², a), 1/2*(1/2+1)
(0.7499999999999998, 0.75)

julia&gt; dot(a, 𝐋⋅𝐒, a)
0.4999999999999999</code></pre><p><strong>Examples with uncoupled orbitals</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a,b,c,d = (SpinOrbital(o&quot;2p&quot;, 1, half(1)),
                  SpinOrbital(o&quot;2p&quot;, -1, half(1)),
                  SpinOrbital(o&quot;2s&quot;, 0, half(1)),
                  SpinOrbital(o&quot;3d&quot;, 2, -half(1)))
(2p₁α, 2p₋₁α, 2s₀α, 3d₂β)

julia&gt; 𝐋,𝐒,𝐉 = OrbitalAngularMomentum(),SpinAngularMomentum(),TotalAngularMomentum()
(𝐋̂⁽¹⁾, 𝐒̂⁽¹⁾, 𝐉̂⁽¹⁾)

julia&gt; 𝐋²,𝐒²,𝐉² = 𝐋⋅𝐋,𝐒⋅𝐒,𝐉⋅𝐉
((𝐋̂⁽¹⁾⋅𝐋̂⁽¹⁾), (𝐒̂⁽¹⁾⋅𝐒̂⁽¹⁾), (𝐉̂⁽¹⁾⋅𝐉̂⁽¹⁾))

julia&gt; dot(a, cartesian_tensor_component(𝐉, :z), a), sum(a.m)
(1.5, 3/2)

julia&gt; dot(a, TensorComponent(𝐋, 0), a)
0.9999999999999999

julia&gt; # Same as previous, but with spin down
       dot(a, TensorComponent(𝐋, 0), SpinOrbital(o&quot;2p&quot;, 1, -half(1)))
0

julia&gt; dot(d, TensorComponent(𝐋, 0), d)
1.9999999999999998

julia&gt; dot(d, TensorComponent(𝐒, 0), d)
-0.49999999999999994

julia&gt; dot(c, cartesian_tensor_component(Gradient(), :x), a)
- 0.408248(∂ᵣ + 2/r)

julia&gt; dot(c, cartesian_tensor_component(SphericalTensor(1), :x), a)
-0.40824829046386285

julia&gt; orbitals = sos&quot;2[p]&quot;
6-element Array{SpinOrbital{Orbital{Int64},Tuple{Int64,Half{Int64}}},1}:
 2p₋₁α
 2p₋₁β
 2p₀α
 2p₀β
 2p₁α
 2p₁β

julia&gt; # Only 2p₋₁β and 2p₁α are pure states, with J = 3/2 =&gt; J(J + 1) = 3.75
       map(o -&gt; dot(o, 𝐉², o), orbitals)
6-element Array{Float64,1}:
 1.7499999999999998
 3.7500000000000004
 2.75
 2.75
 3.7500000000000004
 1.7499999999999998

julia&gt; dot(a, 𝐋², a), 1*(1+1)
(2.0, 2)

julia&gt; dot(d, 𝐋², d), 2*(2+1)
(5.999999999999999, 6)

julia&gt; dot(a, 𝐒², a), half(1)*(half(1)+1)
(0.7499999999999998, 0.75)

julia&gt; dot(a, 𝐋⋅𝐒, a)
0.4999999999999999</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L506-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Tuple{Tuple, TensorScalarProduct, Tuple}" href="#LinearAlgebra.dot-Tuple{Tuple, TensorScalarProduct, Tuple}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot((a,b)::Tuple, X::TensorScalarProduct, (c,d)::Tuple)</code></pre><p>Compute the matrix element <code>⟨a(1)b(2)|𝐓(1)⋅𝐔(2)|c(1)d(2)⟩</code> in the basis of spin-orbitals, dispatching the correct low-level function <code>matrix_element</code> depending on the value of <code>system(X)</code>, where <code>X</code> is the scalar product tensor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 𝐊⁰,𝐊² = CoulombTensor(0),CoulombTensor(2)
(𝐊̂⁽⁰⁾, 𝐊̂⁽²⁾)

julia&gt; a,b = SpinOrbital(o&quot;1s&quot;, 0, half(1)),SpinOrbital(o&quot;3d&quot;, 0, half(1))
(1s₀α, 3d₀α)

julia&gt; dot((a,b), 𝐊⁰⋅𝐊⁰, (a,b))
1.0

julia&gt; dot((a,b), 𝐊²⋅𝐊², (b,a))
0.19999999999999998

julia&gt; a,b = SpinOrbital(ro&quot;1s&quot;, half(1)),SpinOrbital(ro&quot;3d&quot;, half(1))
(1s(1/2), 3d(1/2))

julia&gt; dot((a,b), 𝐊⁰⋅𝐊⁰, (a,b))
1.0

julia&gt; dot((a,b), 𝐊²⋅𝐊², (b,a))
0.12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L654-L686">source</a></section></article><h4 id="Intermediate-level-interface"><a class="docs-heading-anchor" href="#Intermediate-level-interface">Intermediate-level interface</a><a id="Intermediate-level-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Intermediate-level-interface" title="Permalink"></a></h4><p><code>dot</code> dispatches to this level, passing the <a href="../coulomb/#AngularMomentumAlgebra.system-Tuple{Type{CoulombTensor}}"><code>system</code></a> of the tensor operator considered as the first argument. At this level, the spin-orbitals are translated into quantum numbers, employed by the low-level interface.</p><h5 id="Coupled-orbitals"><a class="docs-heading-anchor" href="#Coupled-orbitals">Coupled orbitals</a><a id="Coupled-orbitals-1"></a><a class="docs-heading-anchor-permalink" href="#Coupled-orbitals" title="Permalink"></a></h5><p>In the case of coupled orbitals, <code>RelativisticOrbital</code>s in the nomenclature of AtomicLevels.jl, if the operator acts on the entire system (or at least the total angular momentum), the Wigner–Eckart theorem <span>$\eqref{eqn:wigner-eckart}$</span> can be applied. If however, the operators acts on a subsystem, the uncoupling formula <span>$\eqref{eqn:uncoupling}$</span> has to be employed.</p><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Union{FullSystem, TotalAngularMomentumSubSystem}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Union{FullSystem, TotalAngularMomentumSubSystem}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(::Union{FullSystem,TotalAngularMomentumSubSystem},
               a::SpinOrbital{&lt;:RelativisticOrbital},
               𝐓ᵏq::TensorComponent,
               b::SpinOrbital{&lt;:RelativisticOrbital})</code></pre><p>The matrix element of a tensor acting on the full system or the total angular momentum, evaluated in the basis of coupled spin-orbitals, is simply computed using the Wigner–Eckart theorem <span>$\eqref{eqn:wigner-eckart}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L695-L705">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Any, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Any, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(system,
               a::SpinOrbital{&lt;:RelativisticOrbital},
               𝐓ᵏq::TensorComponent,
               b::SpinOrbital{&lt;:RelativisticOrbital})</code></pre><p>The matrix element of a tensor acting on <code>system</code>, which is a subsystem, evaluated in the basis coupled spin-orbitals, needs to be computed via the uncoupling formula <span>$\eqref{eqn:uncoupling}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L713-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}} where S&lt;:Union{FullSystem, TotalAngularMomentumSubSystem}" href="#AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}} where S&lt;:Union{FullSystem, TotalAngularMomentumSubSystem}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(::Tuple{S,S},
               a::SpinOrbital{&lt;:RelativisticOrbital},
               X::TensorScalarProduct,
               b::SpinOrbital{&lt;:RelativisticOrbital}) where {S&lt;:Union{FullSystem,TotalAngularMomentumSubSystem}}</code></pre><p>The matrix element of a tensor scalar product, where both factors act on the full system or the total angular momentum, evaluated in the basis of coupled spin-orbitals, is computed using <span>$\eqref{eqn:scalar-product-tensor-matrix-element}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L734-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}} where S&lt;:SubSystem" href="#AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}} where S&lt;:SubSystem"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(systems::Tuple{S,S},
               a::SpinOrbital{&lt;:RelativisticOrbital},
               X::TensorScalarProduct,
               b::SpinOrbital{&lt;:RelativisticOrbital}) where {S&lt;:SubSystem}</code></pre><p>The matrix element of a tensor scalar product, where both factors act on the same subsystem, evaluated in the basis of coupled spin-orbitals, is computed using</p><p class="math-container">\[\begin{equation}
\begin{aligned}
&amp;\matrixel{n_1&#39;j_1&#39;n_2&#39;j_2&#39;j&#39;m&#39;}{[\tensor{P}^{(k)}(1)\cdot\tensor{Q}^{(k)}(1)]}{n_1j_1n_2j_2jm}\\
=&amp;\delta_{n_2&#39;n_2}\delta_{j_2&#39;j_2}\delta_{j_1&#39;j_1}\delta_{j&#39;j}\delta_{m&#39;m}
\frac{1}{\angroot{j_1}^2}
(-)^{-j_1}\\
&amp;\times
\sum_{JN}(-)^J
\redmatrixel{n_1&#39;j_1}{\tensor{P}^{(k)}(1)}{NJ}
\redmatrixel{NJ}{\tensor{Q}^{(k)}(1)}{n_1j_1}.
\end{aligned}
\tag{V13.1.43}
\end{equation}\]</p><p>Apart from the additional factor <span>$\delta_{n_2&#39;n_2}\delta_{j_2&#39;j_2}$</span>, this expression is equivalent to <span>$\eqref{eqn:scalar-product-tensor-matrix-element}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L752-L781">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Tuple{SubSystem, SubSystem}, SpinOrbital{var&quot;#s4&quot;, M} where {var&quot;#s4&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s3&quot;, M} where {var&quot;#s3&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Tuple{SubSystem, SubSystem}, SpinOrbital{var&quot;#s4&quot;, M} where {var&quot;#s4&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s3&quot;, M} where {var&quot;#s3&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((s₁,s₂)::Tuple{&lt;:SubSystem,&lt;:SubSystem},
               a::SpinOrbital{&lt;:RelativisticOrbital},
               X::TensorScalarProduct,
               b::SpinOrbital{&lt;:RelativisticOrbital})</code></pre><p>The matrix element of a tensor scalar product, where the factors act on different subsystems, evaluated in the basis of coupled spin-orbitals, is computed using <span>$\eqref{eqn:scalar-product-tensor-matrix-element-diff-coords-coupled}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L792-L802">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Tuple{AngularMomentumAlgebra.System, AngularMomentumAlgebra.System}, Tuple{SpinOrbital{var&quot;#s2&quot;, M} where {var&quot;#s2&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s1&quot;, M} where {var&quot;#s1&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}, TensorScalarProduct, Tuple{SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Tuple{AngularMomentumAlgebra.System, AngularMomentumAlgebra.System}, Tuple{SpinOrbital{var&quot;#s2&quot;, M} where {var&quot;#s2&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s1&quot;, M} where {var&quot;#s1&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}, TensorScalarProduct, Tuple{SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((s₁,s₂)::Tuple{&lt;:System,&lt;:System},
               (a,b)::Tuple{&lt;:SpinOrbital{&lt;:RelativisticOrbital},
                            &lt;:SpinOrbital{&lt;:RelativisticOrbital}},
               X::TensorScalarProduct,
               (c,d)::Tuple{&lt;:SpinOrbital{&lt;:RelativisticOrbital},
                            &lt;:SpinOrbital{&lt;:RelativisticOrbital}})</code></pre><p>The matrix element of a tensor scalar product, where the factors act on the orbital pairs <code>a</code>,<code>c</code> and <code>b</code>,<code>d</code>, respectively, evaluated in the basis of coupled spin-orbitals, is computed using <span>$\eqref{eqn:scalar-product-tensor-matrix-element-diff-coords-uncoupled}$</span> together with <span>$\eqref{eqn:uncoupling}$</span> applied to each matrix element between single orbitals; the individual spin-orbitals couple <span>$\ell$</span> and <span>$s$</span> to form a total <span>$j$</span>, but they are not further coupled to e.g. a term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L812-L828">source</a></section></article><h5 id="Uncoupled-orbitals"><a class="docs-heading-anchor" href="#Uncoupled-orbitals">Uncoupled orbitals</a><a id="Uncoupled-orbitals-1"></a><a class="docs-heading-anchor-permalink" href="#Uncoupled-orbitals" title="Permalink"></a></h5><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Union{FullSystem, TotalAngularMomentumSubSystem}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Union{FullSystem, TotalAngularMomentumSubSystem}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(::Union{FullSystem,TotalAngularMomentumSubSystem},
               a::SpinOrbital{&lt;:Orbital},
               𝐓ᵏq::TensorComponent,
               b::SpinOrbital{&lt;:Orbital})</code></pre><p>The matrix element of a tensor acting on the full system or the total angular momentum, evaluated in the basis of uncoupled spin-orbitals, is computed by transforming to the coupled system via <span>$\eqref{eqn:coupling}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L849-L859">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Any, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Any, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(system,
               a::SpinOrbital{&lt;:Orbital},
               𝐓ᵏq::TensorComponent,
               b::SpinOrbital{&lt;:Orbital})</code></pre><p>The matrix element of a tensor acting on <code>system</code>, which is a subsystem, evaluated in the basis uncoupled spin-orbitals, is given by</p><p class="math-container">\[\begin{equation}
\begin{aligned}
&amp;\matrixel{n_1&#39;j_1&#39;m_1&#39;;n_2&#39;j_2&#39;m_2&#39;}{\tensor{T}^{(k)}_q(1)}{n_1j_1m_1;n_2j_2m_2} \\
=&amp;
\delta_{n_2&#39;n_2}\delta_{j_2&#39;j_2}\delta_{m_2&#39;m_2} \\
&amp;\matrixel{n_1&#39;j_1&#39;m_1&#39;}{\tensor{T}^{(k)}_q(1)}{n_1j_1m_1}.
\end{aligned}
\label{eqn:tensor-matrix-element-subsystem-uncoupled}
\tag{V13.1.39}
\end{equation}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L866-L887">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}} where S&lt;:Union{FullSystem, TotalAngularMomentumSubSystem}" href="#AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}} where S&lt;:Union{FullSystem, TotalAngularMomentumSubSystem}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(::Tuple{S,S},
               a::SpinOrbital{&lt;:Orbital},
               X::TensorScalarProduct,
               b::SpinOrbital{&lt;:Orbital}) where {S&lt;:Union{FullSystem,TotalAngularMomentumSubSystem}}</code></pre><p>The matrix element of a tensor scalar product, where both factors act on the full system or the total angular momentum, evaluated in the basis of uncoupled spin-orbitals, is computed by transforming to the coupled system via <span>$\eqref{eqn:coupling}$</span>, which then dispatches to <span>$\eqref{eqn:scalar-product-tensor-matrix-element}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L897-L908">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}} where S&lt;:SubSystem" href="#AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}} where S&lt;:SubSystem"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(systems::Tuple{S,S},
               a::SpinOrbital{&lt;:Orbital},
               X::TensorScalarProduct,
               b::SpinOrbital{&lt;:Orbital}) where {S&lt;:SubSystem}</code></pre><p>The matrix element of a tensor scalar product, where both factors act on the same subsystem, evaluated in the basis of uncoupled spin-orbitals, is just a special case of <span>$\eqref{eqn:tensor-matrix-element-subsystem-uncoupled}$</span> combined with <span>$\eqref{eqn:scalar-product-tensor-matrix-element}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L916-L927">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Tuple{SubSystem, SubSystem}, SpinOrbital{var&quot;#s8&quot;, M} where {var&quot;#s8&quot;&lt;:Orbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s7&quot;, M} where {var&quot;#s7&quot;&lt;:Orbital, M&lt;:Tuple}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Tuple{SubSystem, SubSystem}, SpinOrbital{var&quot;#s8&quot;, M} where {var&quot;#s8&quot;&lt;:Orbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s7&quot;, M} where {var&quot;#s7&quot;&lt;:Orbital, M&lt;:Tuple}}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((s₁,s₂)::Tuple{&lt;:SubSystem,&lt;:SubSystem},
               a::SpinOrbital{&lt;:Orbital},
               X::TensorScalarProduct,
               b::SpinOrbital{&lt;:Orbital})</code></pre><p>The matrix element of a tensor scalar product, where the factors act on different subsystems, evaluated in the basis of uncoupled spin-orbitals, is computed using <span>$\eqref{eqn:scalar-product-tensor-matrix-element-diff-coords-uncoupled}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L937-L947">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Tuple{AngularMomentumAlgebra.System, AngularMomentumAlgebra.System}, Tuple{SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:Orbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:Orbital, M&lt;:Tuple}}, TensorScalarProduct, Tuple{SpinOrbital{var&quot;#s2&quot;, M} where {var&quot;#s2&quot;&lt;:Orbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s1&quot;, M} where {var&quot;#s1&quot;&lt;:Orbital, M&lt;:Tuple}}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Tuple{AngularMomentumAlgebra.System, AngularMomentumAlgebra.System}, Tuple{SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:Orbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:Orbital, M&lt;:Tuple}}, TensorScalarProduct, Tuple{SpinOrbital{var&quot;#s2&quot;, M} where {var&quot;#s2&quot;&lt;:Orbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s1&quot;, M} where {var&quot;#s1&quot;&lt;:Orbital, M&lt;:Tuple}}}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((s₁,s₂)::Tuple{&lt;:System,&lt;:System},
               (a,b)::Tuple{&lt;:SpinOrbital{&lt;:Orbital},
                            &lt;:SpinOrbital{&lt;:Orbital}},
               X::TensorScalarProduct,
               (c,d)::Tuple{&lt;:SpinOrbital{&lt;:Orbital},
                            &lt;:SpinOrbital{&lt;:Orbital}})</code></pre><p>The matrix element of a tensor scalar product, where the factors act on the orbital pairs <code>a</code>,<code>c</code> and <code>b</code>,<code>d</code>, respectively, evaluated in the basis of uncoupled spin-orbitals, is computed using <span>$\eqref{eqn:scalar-product-tensor-matrix-element-diff-coords-uncoupled}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L957-L969">source</a></section></article><h2 id="Tensor-acts-on-entire-system"><a class="docs-heading-anchor" href="#Tensor-acts-on-entire-system">Tensor acts on entire system</a><a id="Tensor-acts-on-entire-system-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-acts-on-entire-system" title="Permalink"></a></h2><h3 id="wigner_eckart"><a class="docs-heading-anchor" href="#wigner_eckart">The Wigner–Eckart theorem</a><a id="wigner_eckart-1"></a><a class="docs-heading-anchor-permalink" href="#wigner_eckart" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Tuple{Any, Number}, TensorComponent, Tuple{Any, Number}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Tuple{Any, Number}, TensorComponent, Tuple{Any, Number}}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((γj′, m′), Tᵏq::TensorComponent, (γj, m))</code></pre><p>Calculate the matrix element <code>⟨γ′j′m′|Tᵏq|γjm⟩</code> via Wigner–Eckart&#39;s theorem:</p><p class="math-container">\[\begin{equation}
\begin{aligned}
\matrixel{\gamma&#39;j&#39;m&#39;}{\tensor{T}^{(k)}_q}{\gamma jm}
&amp;\defd
(-)^{2k} \frac{1}{\angroot{j&#39;}}
C_{jm;kq}^{j&#39;m&#39;}
\redmatrixel{\gamma&#39; j&#39;}{\tensor{T}^{(k)}}{\gamma j} \\
&amp;=
(-)^{j&#39;-m&#39;}
\begin{pmatrix}
j&#39;&amp;k&amp;j\\
-m&#39;&amp;q&amp;m
\end{pmatrix}
\redmatrixel{\gamma&#39;j&#39;}{\tensor{T}^{(k)}}{\gamma j},
\end{aligned}
\label{eqn:wigner-eckart}
\tag{V13.1.2}
\end{equation}\]</p><p>where the <em>reduced matrix element</em> <span>$\redmatrixel{n&#39;j&#39;}{\tensor{T}^{(k)}}{nj}$</span> does not depend on <span>$m,m&#39;$</span>. <code>j′</code> and <code>j</code> are the total angular momenta with <code>m′</code> and <code>m</code> being their respective projections. <code>γ′</code> and <code>γ</code> are all other quantum numbers needed to fully specify the quantum system; their presence depend on the quantum system.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix_element((2, 1), TensorComponent(OrbitalAngularMomentum(), 1), (2, 0))
-1.7320508075688774

julia&gt; matrix_element((0, 0), TensorComponent(SphericalTensor(1), 0), (1, 0))
0.5773502691896256

julia&gt; matrix_element(((1,half(1),half(1)), -half(1)),
                     TensorComponent(TotalAngularMomentum(), -1),
                     ((1,half(1),half(1)), half(1)))
0.7071067811865475</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L4-L53">source</a></section></article><h3 id="Product-tensors"><a class="docs-heading-anchor" href="#Product-tensors">Product tensors</a><a id="Product-tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Product-tensors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Any, TensorScalarProduct, Any}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Any, TensorScalarProduct, Any}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((γj′, m′), X::TensorScalarProduct, (γj, m))</code></pre><p>Calculate the matrix element of a scalar product tensor according to:</p><p class="math-container">\[\begin{equation}
\begin{aligned}
\matrixel{n&#39;j&#39;m&#39;}{[\tensor{P}^{(k)}\cdot\tensor{Q}^{(k)}]}{njm}
=&amp;
\delta_{jj&#39;}\delta_{mm&#39;}
\frac{1}{\angroot{j}^2}\\
&amp;\times\sum_{n_1j_1}
(-)^{-j+j_1}
\redmatrixel{n&#39;j}{\tensor{P}^{(k)}}{n_1j_1}
\redmatrixel{n_1j_1}{\tensor{Q}^{(k)}}{nj}
\end{aligned}
\label{eqn:scalar-product-tensor-matrix-element}
\tag{V13.1.11}
\end{equation}\]</p><p>The permissible values of <span>$n_1j_1$</span> in the summation are found using <a href="../angular_momenta/#AngularMomentumAlgebra.couplings-Tuple{OrbitalAngularMomentum, Any}"><code>AngularMomentumAlgebra.couplings</code></a>; it is assumed that the summation only consists of a finite amount of terms and that</p><p class="math-container">\[\redmatrixel{n&#39;j}{\tensor{P}^{(k)}}{n_1j_1}\neq0
\iff
\redmatrixel{n_1j_1}{\tensor{P}^{(k)}}{n&#39;j}\neq0,\]</p><p>i.e. that <span>$\tensor{P}^{(k)}$</span> is (skew)symmetric.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 𝐒 = SpinAngularMomentum()
𝐒̂⁽¹⁾

julia&gt; 𝐒² = 𝐒⋅𝐒
(𝐒̂⁽¹⁾⋅𝐒̂⁽¹⁾)

julia&gt; matrix_element((half(1), half(1)),
                      𝐒², (half(1), half(1)))
0.7499999999999998

julia&gt; half(1)*(half(1)+1) # S(S+1)
0.75

julia&gt; 𝐉 = TotalAngularMomentum()
𝐉̂⁽¹⁾

julia&gt; 𝐉² = 𝐉⋅𝐉
(𝐉̂⁽¹⁾⋅𝐉̂⁽¹⁾)

julia&gt; matrix_element(((1, half(1), half(3)), half(3)),
                      𝐉², ((1, half(1), half(3)), half(3)))
3.7500000000000004

julia&gt; half(3)*(half(3)+1) # J(J+1)
3.75</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L74-L137">source</a></section></article><h3 id="Uncoupled-basis-functions"><a class="docs-heading-anchor" href="#Uncoupled-basis-functions">Uncoupled basis functions</a><a id="Uncoupled-basis-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Uncoupled-basis-functions" title="Permalink"></a></h3><p>For a tensor operator that depends on all coordinates, its matrix element in the uncoupled basis are computed via a basis transform to the coupled basis:</p><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-NTuple{5, Any}" href="#AngularMomentumAlgebra.matrix_element-NTuple{5, Any}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((γj₁′, m₁′), (γj₂′, m₂′), 𝐓ᵏq, (γj₁, m₁), (γj₂, m₂))</code></pre><p>Compute the matrix element of the irreducible tensor <code>𝐓ᵏq</code> acting on coordinates <code>1</code> and <code>2</code>, by first coupling <code>γj₁′m₁′γj₂′m₂′</code> and <code>γj₁m₁γj₂m₂</code> to all permissible <code>j′m′</code> and <code>jm</code>, respectively, according to</p><p class="math-container">\[\begin{equation}
\begin{aligned}
&amp;\matrixel{γ_1&#39;j_1&#39;m_1&#39;;γ_2&#39;j_2&#39;m_2&#39;}{\tensor{P}^{(k)}_q(1,2)}{γ_1j_1m_1;γ_2j_2m_2} \\
=&amp; (-)^{2k}
\frac{1}{\angroot{j&#39;}}
\sum_{jmj&#39;m&#39;}
C_{j_1m_1;j_2m_2}^{jm}
C_{j_1&#39;m_1&#39;;j_2&#39;m_2&#39;}^{j&#39;m&#39;}
C_{jm;kq}^{j&#39;m&#39;}\\
&amp;\times
\redmatrixel{γ_1&#39;j_1&#39;γ_2&#39;j_2&#39;j&#39;}{\tensor{P}^{(k)}(1,2)}{γ_1j_1γ_2j_2j} \\
\equiv&amp;
\sum_{jmj&#39;m&#39;}
C_{j_1m_1;j_2m_2}^{jm}
C_{j_1&#39;m_1&#39;;j_2&#39;m_2&#39;}^{j&#39;m&#39;}
\matrixel{γ_1&#39;j_1&#39;γ_2&#39;j_2&#39;j&#39;m&#39;}{\tensor{P}^{(k)}(1,2)}{γ_1j_1γ_2j_2jm}
\end{aligned}
\tag{V13.1.23}
\label{eqn:coupling}
\end{equation}\]</p><p>The non-vanishing terms of the sum are found using <a href="../angular_momenta/#AngularMomentumAlgebra.couplings-Tuple{OrbitalAngularMomentum, Any}"><code>AngularMomentumAlgebra.couplings</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 𝐉 = TotalAngularMomentum()
𝐉̂⁽¹⁾

julia&gt; 𝐉₀ = TensorComponent(𝐉, 0)
𝐉̂⁽¹⁾₀

julia&gt; matrix_element((1,1), (half(1),half(1)),
                      𝐉₀, (1,1), (half(1), half(1)))
1.5

julia&gt; matrix_element((1,-1), (half(1),half(1)),
                      𝐉₀, (1,-1), (half(1), half(1)))
-0.4999999999999999

julia&gt; 𝐉₁ = TensorComponent(𝐉, 1)
𝐉̂⁽¹⁾₁

julia&gt; matrix_element((1,1), (half(1),half(1)),
                      𝐉₁, (1,0), (half(1), half(1)))
-1.0

julia&gt; 𝐉² = 𝐉⋅𝐉
(𝐉̂⁽¹⁾⋅𝐉̂⁽¹⁾)

julia&gt; matrix_element((1,1), (half(1),half(1)),
                      𝐉², (1,1), (half(1), half(1)))
3.7500000000000004

julia&gt; half(3)*(half(3)+1) # J(J+1)
3.75</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L161-L229">source</a></section></article><h2 id="Tensor-acts-on-subsystems"><a class="docs-heading-anchor" href="#Tensor-acts-on-subsystems">Tensor acts on subsystems</a><a id="Tensor-acts-on-subsystems-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-acts-on-subsystems" title="Permalink"></a></h2><h3 id="Uncoupling"><a class="docs-heading-anchor" href="#Uncoupling">Uncoupling</a><a id="Uncoupling-1"></a><a class="docs-heading-anchor-permalink" href="#Uncoupling" title="Permalink"></a></h3><p>When the tensor operator is reducible and only acts on one part of the quantum system, in the coupled basis we employ the following uncoupling formula:</p><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Tuple{Any, Any, Number, Number}, TensorComponent, Tuple{Any, Any, Number, Number}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Tuple{Any, Any, Number, Number}, TensorComponent, Tuple{Any, Any, Number, Number}}"><code>AngularMomentumAlgebra.matrix_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((γj₁′, γj₂′, j′, m′), 𝐓ᵏq, (γj₁, γj₂, j, m))</code></pre><p>Compute the matrix element of the tensor <code>𝐓ᵏq</code> which acts on coordinate <code>1</code> only in the coupled basis, by employing the uncoupling formula</p><p class="math-container">\[\begin{equation}
\begin{aligned}
&amp;\matrixel{γ_1&#39;j_1&#39;γ_2&#39;j_2&#39;j&#39;m&#39;}{\tensor{T}^{(k)}_q(1)}{γ_1j_1γ_2j_2jm}\\
=&amp; \delta_{j_2&#39;j_2}\delta_{γ_2&#39;γ_2}
(-)^{j+j_1&#39;+j_2-k}
\angroot{j}
C_{jm;kq}^{j&#39;m&#39;}\\
&amp;\times
\wignersixj{j_1&amp;j_2&amp;j\\j&#39;&amp;k&amp;j_1&#39;}
\redmatrixel{γ_1&#39;j_1&#39;}{\tensor{T}^{(k)}(1)}{γ_1j_1}
\end{aligned}
\tag{V13.1.40}
\label{eqn:uncoupling}
\end{equation}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 𝐋₀ = TensorComponent(OrbitalAngularMomentum(), 0)
𝐋̂⁽¹⁾₀

julia&gt; matrix_element((1, half(1), half(3), half(3)),
                      𝐋₀, (1, half(1), half(3), half(3)))
0.9999999999999999

julia&gt; matrix_element((1, 1), 𝐋₀, (1, 1)) # For comparison
0.9999999999999999

julia&gt; 𝐒₀ = TensorComponent(SpinAngularMomentum(), 0)
𝐒̂⁽¹⁾₀

julia&gt; matrix_element((half(1), 1, half(3), half(3)),
                      𝐒₀, (half(1), 1, half(3), half(3)))
0.49999999999999994

julia&gt; matrix_element((half(1),half(1)), 𝐒₀, (half(1),half(1)))
0.49999999999999994</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L255-L303">source</a></section></article><h3 id="Evaluation-in-subspace"><a class="docs-heading-anchor" href="#Evaluation-in-subspace">Evaluation in subspace</a><a id="Evaluation-in-subspace-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-in-subspace" title="Permalink"></a></h3><p>In the uncoupled basis, the matrix element of a tensor operator acting only on a subsystem is simply given by the appropriate <a href="#AngularMomentumAlgebra.matrix_element-Tuple{Union{FullSystem, TotalAngularMomentumSubSystem}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}"><code>matrix_element</code></a> applied to the quantum numbers characterizing the subspace, with the extra diagonality constraint for the <a href="../orbitals/#AngularMomentumAlgebra.other_quantum_numbers"><code>other_quantum_numbers</code></a> enforced using <a href="../common/#AngularMomentumAlgebra.@δ"><code>AngularMomentumAlgebra.@δ</code></a>.</p><h3 id="Product-tensors-2"><a class="docs-heading-anchor" href="#Product-tensors-2">Product tensors</a><a class="docs-heading-anchor-permalink" href="#Product-tensors-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element2-Tuple{Any, Any, TensorScalarProduct, Any, Any}" href="#AngularMomentumAlgebra.matrix_element2-Tuple{Any, Any, TensorScalarProduct, Any, Any}"><code>AngularMomentumAlgebra.matrix_element2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element2(γjm₁′, γjm₂′, X::TensorScalarProduct, γjm₁, γjm₂)</code></pre><p>The matrix element of a scalar product of two tensors acting on different coordinates is given by (in the uncoupled basis)</p><p class="math-container">\[\begin{equation}
\begin{aligned}
&amp;\matrixel{\gamma_1&#39;j_1&#39;m_1&#39;;\gamma_2&#39;j_2&#39;m_2&#39;}{[\tensor{P}^{(k)}(1)\cdot\tensor{Q}^{(k)}(2)]}{\gamma_1j_1m_1;\gamma_2j_2m_2}\\
=&amp;
\frac{1}{\angroot{j_1&#39;j_2&#39;}}
\sum_\alpha(-)^{-\alpha}
C_{j_1m_1;k,\alpha}^{j_1&#39;m_1&#39;}
C_{j_2m_2;k,-\alpha}^{j_2&#39;m_2&#39;}\\
&amp;\times
\redmatrixel{\gamma_1&#39;j_1&#39;}{\tensor{P}^{(k)}(1)}{\gamma_1j_1}
\redmatrixel{\gamma_2&#39;j_2&#39;}{\tensor{Q}^{(k)}(2)}{\gamma_2j_2} \\
\equiv&amp;
\sum_\alpha
(-)^{-\alpha}
\matrixel{\gamma_1&#39;j_1&#39;m_1&#39;}{\tensor{P}^{(k)}_{\alpha}(1)}{\gamma_1j_1m_1}
\matrixel{\gamma_2&#39;j_2&#39;m_2&#39;}{\tensor{Q}^{(k)}_{-\alpha}(2)}{\gamma_2j_2m_2}
\end{aligned}
\tag{V13.1.26}
\label{eqn:scalar-product-tensor-matrix-element-diff-coords-uncoupled}
\end{equation}\]</p><p>Since the <a href="../definitions/#Clebsch–Gordan-coefficients">Clebsch–Gordan coefficients</a> can be rewritten using 3j symbols and the 3j symbols vanish unless <span>$m_1 + \alpha - m_1&#39; = m_2 - \alpha - m_2&#39; = 0$</span>, we have</p><p class="math-container">\[\alpha = m_1&#39; - m_1 = m_2-m_2&#39;\]</p><p>This case occurs in two-body interactions, such as the <a href="../coulomb/#Coulomb-interaction">Coulomb interaction</a>, where <span>$1&#39;,1$</span> and <span>$2&#39;,2$</span> are pairs of orbitals and the scalar product tensor is a term in the multipole expansion in terms of <a href="../spherical_tensors/#tensors_spherical_tensors">Spherical tensors</a>:</p><pre><code class="language-julia-repl hljs">julia&gt; 𝐂⁰ = SphericalTensor(0)
𝐂̂⁽⁰⁾

julia&gt; matrix_element2((0, 0), (0, 0), 𝐂⁰⋅𝐂⁰, (0,0), (0, 0)) # ⟨1s₀,1s₀|𝐂⁰⋅𝐂⁰|1s₀,1s₀⟩
1.0

julia&gt; 𝐂¹ = SphericalTensor(1)
𝐂̂⁽¹⁾

julia&gt; matrix_element2((0, 0), (1, 0), 𝐂¹⋅𝐂¹, (1,0), (2, 0)) # ⟨1s₀,2p₀|𝐂¹⋅𝐂¹|2p₀,3d₀⟩
0.29814239699997186

julia&gt; matrix_element2((0, 0), (1, 1), 𝐂¹⋅𝐂¹, (1,0), (2, 1)) # ⟨1s₀,2p₁|𝐂¹⋅𝐂¹|2p₀,3d₁⟩
0.25819888974716104</code></pre><p>but also in the case of the operator <span>$\tensor{L}\cdot\tensor{S}$</span> and coordinates <span>$1$</span> and <span>$2$</span> correspond to orbital and spin angular momenta, respectively. We can verify this using the classical result known from spin–orbit splitting:</p><p class="math-container">\[\begin{aligned}
J^2 &amp;= (\tensor{L}+\tensor{S})^2 = L^2 + 2\tensor{L}\cdot\tensor{S} + S^2\\
\implies
\expect{\tensor{L}\cdot\tensor{S}} &amp;=
\frac{1}{2}(\expect{J^2} - \expect{L^2} - \expect{S^2}) =
\frac{1}{2}[J(J+1) - L(L+1) - S(S+1)]
\end{aligned}\]</p><p>In the uncoupled basis, <span>$J$</span> is not a good quantum number (it is not a constant of motion), except for <em>pure states</em>, i.e. those with maximal <span>$\abs{m_\ell + m_s}$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; X = OrbitalAngularMomentum()⋅SpinAngularMomentum()
(𝐋̂⁽¹⁾⋅𝐒̂⁽¹⁾)

julia&gt; matrix_element2((1, 1), (half(1), half(1)),
                      X, (1,1), (half(1), half(1)))
0.4999999999999999

julia&gt; 1/2*(half(3)*(half(3)+1)-1*(1+1)-half(1)*(half(1)+1)) # 1/2(J(J+1)-L(L+1)-S(S+1))
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L357-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element2-Tuple{Any, TensorScalarProduct, Any}" href="#AngularMomentumAlgebra.matrix_element2-Tuple{Any, TensorScalarProduct, Any}"><code>AngularMomentumAlgebra.matrix_element2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element2((γj₁′, γj₂′, j′, m′), X::TensorScalarProduct, (γj₁, γj₂, j, m))</code></pre><p>The matrix element of a scalar product of two tensors acting on different coordinates is given by (in the coupled basis)</p><p class="math-container">\[\begin{equation}
\begin{aligned}
&amp;\matrixel{n_1&#39;j_1&#39;n_2&#39;j_2&#39;j&#39;m&#39;}{[\tensor{P}^{(k)}(1)\cdot\tensor{Q}^{(k)}(2)]}{n_1j_1n_2j_2jm}\\
=&amp; \delta_{j&#39;j}\delta_{m&#39;m}
(-)^{j+j_1+j_2&#39;}
\wignersixj{j_1&#39;&amp;j_1&amp;k\\j_2&amp;j_2&#39;&amp;j}\\
&amp;\times
\redmatrixel{n_1&#39;j_1&#39;}{\tensor{P}^{(k)}(1)}{n_1j_1}
\redmatrixel{n_2&#39;j_2&#39;}{\tensor{Q}^{(k)}(2)}{n_2j_2}.
\end{aligned}
\tag{V13.1.29}
\label{eqn:scalar-product-tensor-matrix-element-diff-coords-coupled}
\end{equation}\]</p><pre><code class="language-julia-repl hljs">julia&gt; X = OrbitalAngularMomentum()⋅SpinAngularMomentum()
(𝐋̂⁽¹⁾⋅𝐒̂⁽¹⁾)

julia&gt; matrix_element2((1, half(1), half(3), half(3)),
                       X, (1, half(1), half(3), half(3)))
0.4999999999999999</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L459-L489">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../coulomb/">« Coulomb interaction</a><a class="docs-footer-nextpage" href="../energy_expressions/">Energy expressions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Tuesday 8 November 2022 17:02">Tuesday 8 November 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
