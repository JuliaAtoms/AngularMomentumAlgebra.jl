<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tensor matrix elements Â· AngularMomentumAlgebra</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AngularMomentumAlgebra</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../definitions/">Definitions</a></li><li><a class="tocitem" href="../common/">Common routines</a></li><li><a class="tocitem" href="../orbitals/">Orbitals</a></li><li><span class="tocitem">Tensors</span><ul><li><a class="tocitem" href="../tensors/">General tensors</a></li><li><a class="tocitem" href="../tensor_dsl/">Tensor DSL</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Various tensors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../angular_momenta/">Angular momenta</a></li><li><a class="tocitem" href="../spherical_tensors/">Spherical tensors</a></li><li><a class="tocitem" href="../gradients/">Gradients</a></li><li><a class="tocitem" href="../multipole_expansions/">Multipole expansions</a></li><li><a class="tocitem" href="../coulomb/">Coulomb interaction</a></li></ul></li><li class="is-active"><a class="tocitem" href>Tensor matrix elements</a><ul class="internal"><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Tensor-acts-on-entire-system"><span>Tensor acts on entire system</span></a></li><li><a class="tocitem" href="#Tensor-acts-on-subsystems"><span>Tensor acts on subsystems</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../energy_expressions/">Energy expressions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tensors</a></li><li class="is-active"><a href>Tensor matrix elements</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tensor matrix elements</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/master/docs/src/tensor_matrix_elements.md" title="Edit source on GitHub"><span class="docs-icon fas">ï„</span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tensor-matrix-elements"><a class="docs-heading-anchor" href="#Tensor-matrix-elements">Tensor matrix elements</a><a id="Tensor-matrix-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-matrix-elements" title="Permalink"></a></h1><p>The matrix element of any irreducible tensor operator of rank <span>$k$</span> is defined as</p><p class="math-container">\[\begin{equation}
\tag{V13.1.1}
\matrixel{n&#39;j&#39;m&#39;}{\tensor{T}^{(k)}_q}{njm} \defd
\int\diff{\tau}
\conj{\Psi}_{n&#39;j&#39;m&#39;}
\tensor{T}^{(k)}_q
\Psi_{njm}.
\end{equation}\]</p><p>For simple quantum systems, it is most easily evaluated using <a href="#wigner_eckart">the Wignerâ€“Eckart theorem</a>; however, in most cases, the quantum system and/or the tensor is composed of multiple parts, which complicates the situation. The table below shows the most common cases:</p><table><tr><th style="text-align: right">Basis \ Tensor</th><th style="text-align: right">Acts on entire system</th><th style="text-align: right">Acts on subsystems</th></tr><tr><td style="text-align: right"><strong>Uncoupled</strong></td><td style="text-align: right">Transform to coupled basis: <span>$\eqref{eqn:coupling}$</span></td><td style="text-align: right"><a href="#Evaluation-in-subspace">Evaluation in subspace</a></td></tr><tr><td style="text-align: right"><strong>Coupled</strong></td><td style="text-align: right">Wignerâ€“Eckart: <span>$\eqref{eqn:wigner-eckart}$</span></td><td style="text-align: right">Uncoupling: <span>$\eqref{eqn:uncoupling}$</span></td></tr></table><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><p>There are two interfaces provided for computation of matrix element of tensor operators:</p><ul><li>A low-level interface <code>matrix_element((Î³jâ€², mâ€²), ğ“áµq, (Î³jâ€², mâ€²))</code> (and friends), where <code>Î³jâ€²</code>, <code>mâ€²</code>, <code>Î³jâ€²</code>, and <code>mâ€²</code> are quantum numbers.</li><li>A high-level interface <code>dot(a, ğ“áµq, b)</code>, where <code>a</code> and <code>b</code> are <code>SpinOrbital</code>s from <a href="https://github.com/JuliaAtoms/AtomicLevels.jl.git">AtomicLevels.jl</a>. The high-level interface dispatches as appropriate to the low-level interface, depending on whether <code>a</code> and <code>b</code> are expressed in the coupled basis or not, and which part of the quantum system <code>ğ“áµq</code> acts on.</li></ul><h3 id="High-level-interface"><a class="docs-heading-anchor" href="#High-level-interface">High-level interface</a><a id="High-level-interface-1"></a><a class="docs-heading-anchor-permalink" href="#High-level-interface" title="Permalink"></a></h3><p>There are two main functions in the high-level interface:</p><ul><li><code>dot(a, ğ“áµq, b)</code> for one-body interactions</li><li><code>dot((a,b), ğ“áµq, (c,d))</code> for two-body interactions (e.g. <a href="../coulomb/#Coulomb-interaction">Coulomb interaction</a>).</li></ul><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Tuple{SpinOrbital, TensorComponent, SpinOrbital}" href="#LinearAlgebra.dot-Tuple{SpinOrbital, TensorComponent, SpinOrbital}"><code>LinearAlgebra.dot</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot(a::SpinOrbital,
    ğ“áµq::Union{TensorComponent,TensorScalarProduct},
    b::SpinOrbital)</code></pre><p>Compute the matrix element <code>âŸ¨a|ğ“áµq|bâŸ©</code> in the basis of spin-orbitals, dispatching to the correct low-level function <code>matrix_element</code>, depending on the value of <code>system(ğ“áµq)</code>.</p><p><strong>Examples with coupled orbitals</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a,b,c,d = (SpinOrbital(ro&quot;2p&quot;, half(3)),
                  SpinOrbital(ro&quot;2p&quot;, half(1)),
                  SpinOrbital(ro&quot;2s&quot;, half(1)),
                  SpinOrbital(ro&quot;3d&quot;, half(3)))
(2p(3/2), 2p(1/2), 2s(1/2), 3d(3/2))

julia&gt; ğ‹, ğ’, ğ‰ = OrbitalAngularMomentum(), SpinAngularMomentum(), TotalAngularMomentum()
(ğ‹Ì‚â½Â¹â¾, ğ’Ì‚â½Â¹â¾, ğ‰Ì‚â½Â¹â¾)

julia&gt; ğ‹Â², ğ’Â², ğ‰Â² = ğ‹â‹…ğ‹, ğ’â‹…ğ’, ğ‰â‹…ğ‰
((ğ‹Ì‚â½Â¹â¾â‹…ğ‹Ì‚â½Â¹â¾), (ğ’Ì‚â½Â¹â¾â‹…ğ’Ì‚â½Â¹â¾), (ğ‰Ì‚â½Â¹â¾â‹…ğ‰Ì‚â½Â¹â¾))

julia&gt; dot(a, cartesian_tensor_component(ğ‰, :x), b),
           1/2*âˆš((3/2+1/2+1)*(3/2-1/2)) # 1/2âˆš((J+M+1)*(J-M))
(0.8660254037844386, 0.8660254037844386)

julia&gt; dot(a, cartesian_tensor_component(ğ‰, :z), a), a.m[1]
(1.5, 3/2)

julia&gt; dot(a, TensorComponent(ğ‹, 0), a)
0.9999999999999999

julia&gt; dot(c, cartesian_tensor_component(Gradient(), :x), a)
- 0.408248(âˆ‚áµ£ + 2/r)

julia&gt; dot(c, cartesian_tensor_component(SphericalTensor(1), :x), a)
-0.40824829046386296

julia&gt; orbitals = rsos&quot;2[p]&quot;
6-element Array{SpinOrbital{RelativisticOrbital{Int64},Tuple{Half{Int64}}},1}:
 2p-(-1/2)
 2p-(1/2)
 2p(-3/2)
 2p(-1/2)
 2p(1/2)
 2p(3/2)

julia&gt; map(o -&gt; dot(o, ğ‰Â², o), orbitals)
6-element Array{Float64,1}:
 0.7499999999999998
 0.7499999999999998
 3.7500000000000004
 3.7500000000000004
 3.7500000000000004
 3.7500000000000004

julia&gt; 1/2*(1/2+1),3/2*(3/2+1) # J(J+1)
(0.75, 3.75)

julia&gt; dot(a, ğ‹Â², a), 1*(1+1)
(2.0, 2)

julia&gt; dot(d, ğ‹Â², d), 2*(2+1)
(5.999999999999999, 6)

julia&gt; dot(a, ğ’Â², a), 1/2*(1/2+1)
(0.7499999999999998, 0.75)

julia&gt; dot(a, ğ‹â‹…ğ’, a)
0.4999999999999999</code></pre><p><strong>Examples with uncoupled orbitals</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a,b,c,d = (SpinOrbital(o&quot;2p&quot;, 1, half(1)),
                  SpinOrbital(o&quot;2p&quot;, -1, half(1)),
                  SpinOrbital(o&quot;2s&quot;, 0, half(1)),
                  SpinOrbital(o&quot;3d&quot;, 2, -half(1)))
(2pâ‚Î±, 2pâ‚‹â‚Î±, 2sâ‚€Î±, 3dâ‚‚Î²)

julia&gt; ğ‹,ğ’,ğ‰ = OrbitalAngularMomentum(),SpinAngularMomentum(),TotalAngularMomentum()
(ğ‹Ì‚â½Â¹â¾, ğ’Ì‚â½Â¹â¾, ğ‰Ì‚â½Â¹â¾)

julia&gt; ğ‹Â²,ğ’Â²,ğ‰Â² = ğ‹â‹…ğ‹,ğ’â‹…ğ’,ğ‰â‹…ğ‰
((ğ‹Ì‚â½Â¹â¾â‹…ğ‹Ì‚â½Â¹â¾), (ğ’Ì‚â½Â¹â¾â‹…ğ’Ì‚â½Â¹â¾), (ğ‰Ì‚â½Â¹â¾â‹…ğ‰Ì‚â½Â¹â¾))

julia&gt; dot(a, cartesian_tensor_component(ğ‰, :z), a), sum(a.m)
(1.5, 3/2)

julia&gt; dot(a, TensorComponent(ğ‹, 0), a)
0.9999999999999999

julia&gt; # Same as previous, but with spin down
       dot(a, TensorComponent(ğ‹, 0), SpinOrbital(o&quot;2p&quot;, 1, -half(1)))
0

julia&gt; dot(d, TensorComponent(ğ‹, 0), d)
1.9999999999999998

julia&gt; dot(d, TensorComponent(ğ’, 0), d)
-0.49999999999999994

julia&gt; dot(c, cartesian_tensor_component(Gradient(), :x), a)
- 0.408248(âˆ‚áµ£ + 2/r)

julia&gt; dot(c, cartesian_tensor_component(SphericalTensor(1), :x), a)
-0.40824829046386285

julia&gt; orbitals = sos&quot;2[p]&quot;
6-element Array{SpinOrbital{Orbital{Int64},Tuple{Int64,Half{Int64}}},1}:
 2pâ‚‹â‚Î±
 2pâ‚‹â‚Î²
 2pâ‚€Î±
 2pâ‚€Î²
 2pâ‚Î±
 2pâ‚Î²

julia&gt; # Only 2pâ‚‹â‚Î² and 2pâ‚Î± are pure states, with J = 3/2 =&gt; J(J + 1) = 3.75
       map(o -&gt; dot(o, ğ‰Â², o), orbitals)
6-element Array{Float64,1}:
 1.7499999999999998
 3.7500000000000004
 2.75
 2.75
 3.7500000000000004
 1.7499999999999998

julia&gt; dot(a, ğ‹Â², a), 1*(1+1)
(2.0, 2)

julia&gt; dot(d, ğ‹Â², d), 2*(2+1)
(5.999999999999999, 6)

julia&gt; dot(a, ğ’Â², a), half(1)*(half(1)+1)
(0.7499999999999998, 0.75)

julia&gt; dot(a, ğ‹â‹…ğ’, a)
0.4999999999999999</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L506-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Tuple{Tuple, TensorScalarProduct, Tuple}" href="#LinearAlgebra.dot-Tuple{Tuple, TensorScalarProduct, Tuple}"><code>LinearAlgebra.dot</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot((a,b)::Tuple, X::TensorScalarProduct, (c,d)::Tuple)</code></pre><p>Compute the matrix element <code>âŸ¨a(1)b(2)|ğ“(1)â‹…ğ”(2)|c(1)d(2)âŸ©</code> in the basis of spin-orbitals, dispatching the correct low-level function <code>matrix_element</code> depending on the value of <code>system(X)</code>, where <code>X</code> is the scalar product tensor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ğŠâ°,ğŠÂ² = CoulombTensor(0),CoulombTensor(2)
(ğŠÌ‚â½â°â¾, ğŠÌ‚â½Â²â¾)

julia&gt; a,b = SpinOrbital(o&quot;1s&quot;, 0, half(1)),SpinOrbital(o&quot;3d&quot;, 0, half(1))
(1sâ‚€Î±, 3dâ‚€Î±)

julia&gt; dot((a,b), ğŠâ°â‹…ğŠâ°, (a,b))
1.0

julia&gt; dot((a,b), ğŠÂ²â‹…ğŠÂ², (b,a))
0.19999999999999998

julia&gt; a,b = SpinOrbital(ro&quot;1s&quot;, half(1)),SpinOrbital(ro&quot;3d&quot;, half(1))
(1s(1/2), 3d(1/2))

julia&gt; dot((a,b), ğŠâ°â‹…ğŠâ°, (a,b))
1.0

julia&gt; dot((a,b), ğŠÂ²â‹…ğŠÂ², (b,a))
0.12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L654-L686">source</a></section></article><h4 id="Intermediate-level-interface"><a class="docs-heading-anchor" href="#Intermediate-level-interface">Intermediate-level interface</a><a id="Intermediate-level-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Intermediate-level-interface" title="Permalink"></a></h4><p><code>dot</code> dispatches to this level, passing the <a href="../coulomb/#AngularMomentumAlgebra.system-Tuple{Type{CoulombTensor}}"><code>system</code></a> of the tensor operator considered as the first argument. At this level, the spin-orbitals are translated into quantum numbers, employed by the low-level interface.</p><h5 id="Coupled-orbitals"><a class="docs-heading-anchor" href="#Coupled-orbitals">Coupled orbitals</a><a id="Coupled-orbitals-1"></a><a class="docs-heading-anchor-permalink" href="#Coupled-orbitals" title="Permalink"></a></h5><p>In the case of coupled orbitals, <code>RelativisticOrbital</code>s in the nomenclature of AtomicLevels.jl, if the operator acts on the entire system (or at least the total angular momentum), the Wignerâ€“Eckart theorem <span>$\eqref{eqn:wigner-eckart}$</span> can be applied. If however, the operators acts on a subsystem, the uncoupling formula <span>$\eqref{eqn:uncoupling}$</span> has to be employed.</p><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Union{FullSystem, TotalAngularMomentumSubSystem}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Union{FullSystem, TotalAngularMomentumSubSystem}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(::Union{FullSystem,TotalAngularMomentumSubSystem},
               a::SpinOrbital{&lt;:RelativisticOrbital},
               ğ“áµq::TensorComponent,
               b::SpinOrbital{&lt;:RelativisticOrbital})</code></pre><p>The matrix element of a tensor acting on the full system or the total angular momentum, evaluated in the basis of coupled spin-orbitals, is simply computed using the Wignerâ€“Eckart theorem <span>$\eqref{eqn:wigner-eckart}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L695-L705">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Any, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Any, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(system,
               a::SpinOrbital{&lt;:RelativisticOrbital},
               ğ“áµq::TensorComponent,
               b::SpinOrbital{&lt;:RelativisticOrbital})</code></pre><p>The matrix element of a tensor acting on <code>system</code>, which is a subsystem, evaluated in the basis coupled spin-orbitals, needs to be computed via the uncoupling formula <span>$\eqref{eqn:uncoupling}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L713-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}} where S&lt;:Union{FullSystem, TotalAngularMomentumSubSystem}" href="#AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}} where S&lt;:Union{FullSystem, TotalAngularMomentumSubSystem}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(::Tuple{S,S},
               a::SpinOrbital{&lt;:RelativisticOrbital},
               X::TensorScalarProduct,
               b::SpinOrbital{&lt;:RelativisticOrbital}) where {S&lt;:Union{FullSystem,TotalAngularMomentumSubSystem}}</code></pre><p>The matrix element of a tensor scalar product, where both factors act on the full system or the total angular momentum, evaluated in the basis of coupled spin-orbitals, is computed using <span>$\eqref{eqn:scalar-product-tensor-matrix-element}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L734-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}} where S&lt;:SubSystem" href="#AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}} where S&lt;:SubSystem"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(systems::Tuple{S,S},
               a::SpinOrbital{&lt;:RelativisticOrbital},
               X::TensorScalarProduct,
               b::SpinOrbital{&lt;:RelativisticOrbital}) where {S&lt;:SubSystem}</code></pre><p>The matrix element of a tensor scalar product, where both factors act on the same subsystem, evaluated in the basis of coupled spin-orbitals, is computed using</p><p class="math-container">\[\begin{equation}
\begin{aligned}
&amp;\matrixel{n_1&#39;j_1&#39;n_2&#39;j_2&#39;j&#39;m&#39;}{[\tensor{P}^{(k)}(1)\cdot\tensor{Q}^{(k)}(1)]}{n_1j_1n_2j_2jm}\\
=&amp;\delta_{n_2&#39;n_2}\delta_{j_2&#39;j_2}\delta_{j_1&#39;j_1}\delta_{j&#39;j}\delta_{m&#39;m}
\frac{1}{\angroot{j_1}^2}
(-)^{-j_1}\\
&amp;\times
\sum_{JN}(-)^J
\redmatrixel{n_1&#39;j_1}{\tensor{P}^{(k)}(1)}{NJ}
\redmatrixel{NJ}{\tensor{Q}^{(k)}(1)}{n_1j_1}.
\end{aligned}
\tag{V13.1.43}
\end{equation}\]</p><p>Apart from the additional factor <span>$\delta_{n_2&#39;n_2}\delta_{j_2&#39;j_2}$</span>, this expression is equivalent to <span>$\eqref{eqn:scalar-product-tensor-matrix-element}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L752-L781">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Tuple{SubSystem, SubSystem}, SpinOrbital{var&quot;#s4&quot;, M} where {var&quot;#s4&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s3&quot;, M} where {var&quot;#s3&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Tuple{SubSystem, SubSystem}, SpinOrbital{var&quot;#s4&quot;, M} where {var&quot;#s4&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s3&quot;, M} where {var&quot;#s3&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((sâ‚,sâ‚‚)::Tuple{&lt;:SubSystem,&lt;:SubSystem},
               a::SpinOrbital{&lt;:RelativisticOrbital},
               X::TensorScalarProduct,
               b::SpinOrbital{&lt;:RelativisticOrbital})</code></pre><p>The matrix element of a tensor scalar product, where the factors act on different subsystems, evaluated in the basis of coupled spin-orbitals, is computed using <span>$\eqref{eqn:scalar-product-tensor-matrix-element-diff-coords-coupled}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L792-L802">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Tuple{AngularMomentumAlgebra.System, AngularMomentumAlgebra.System}, Tuple{SpinOrbital{var&quot;#s2&quot;, M} where {var&quot;#s2&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s1&quot;, M} where {var&quot;#s1&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}, TensorScalarProduct, Tuple{SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Tuple{AngularMomentumAlgebra.System, AngularMomentumAlgebra.System}, Tuple{SpinOrbital{var&quot;#s2&quot;, M} where {var&quot;#s2&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s1&quot;, M} where {var&quot;#s1&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}, TensorScalarProduct, Tuple{SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((sâ‚,sâ‚‚)::Tuple{&lt;:System,&lt;:System},
               (a,b)::Tuple{&lt;:SpinOrbital{&lt;:RelativisticOrbital},
                            &lt;:SpinOrbital{&lt;:RelativisticOrbital}},
               X::TensorScalarProduct,
               (c,d)::Tuple{&lt;:SpinOrbital{&lt;:RelativisticOrbital},
                            &lt;:SpinOrbital{&lt;:RelativisticOrbital}})</code></pre><p>The matrix element of a tensor scalar product, where the factors act on the orbital pairs <code>a</code>,<code>c</code> and <code>b</code>,<code>d</code>, respectively, evaluated in the basis of coupled spin-orbitals, is computed using <span>$\eqref{eqn:scalar-product-tensor-matrix-element-diff-coords-uncoupled}$</span> together with <span>$\eqref{eqn:uncoupling}$</span> applied to each matrix element between single orbitals; the individual spin-orbitals couple <span>$\ell$</span> and <span>$s$</span> to form a total <span>$j$</span>, but they are not further coupled to e.g. a term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L812-L828">source</a></section></article><h5 id="Uncoupled-orbitals"><a class="docs-heading-anchor" href="#Uncoupled-orbitals">Uncoupled orbitals</a><a id="Uncoupled-orbitals-1"></a><a class="docs-heading-anchor-permalink" href="#Uncoupled-orbitals" title="Permalink"></a></h5><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Union{FullSystem, TotalAngularMomentumSubSystem}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Union{FullSystem, TotalAngularMomentumSubSystem}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(::Union{FullSystem,TotalAngularMomentumSubSystem},
               a::SpinOrbital{&lt;:Orbital},
               ğ“áµq::TensorComponent,
               b::SpinOrbital{&lt;:Orbital})</code></pre><p>The matrix element of a tensor acting on the full system or the total angular momentum, evaluated in the basis of uncoupled spin-orbitals, is computed by transforming to the coupled system via <span>$\eqref{eqn:coupling}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L849-L859">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Any, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Any, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(system,
               a::SpinOrbital{&lt;:Orbital},
               ğ“áµq::TensorComponent,
               b::SpinOrbital{&lt;:Orbital})</code></pre><p>The matrix element of a tensor acting on <code>system</code>, which is a subsystem, evaluated in the basis uncoupled spin-orbitals, is given by</p><p class="math-container">\[\begin{equation}
\begin{aligned}
&amp;\matrixel{n_1&#39;j_1&#39;m_1&#39;;n_2&#39;j_2&#39;m_2&#39;}{\tensor{T}^{(k)}_q(1)}{n_1j_1m_1;n_2j_2m_2} \\
=&amp;
\delta_{n_2&#39;n_2}\delta_{j_2&#39;j_2}\delta_{m_2&#39;m_2} \\
&amp;\matrixel{n_1&#39;j_1&#39;m_1&#39;}{\tensor{T}^{(k)}_q(1)}{n_1j_1m_1}.
\end{aligned}
\label{eqn:tensor-matrix-element-subsystem-uncoupled}
\tag{V13.1.39}
\end{equation}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L866-L887">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}} where S&lt;:Union{FullSystem, TotalAngularMomentumSubSystem}" href="#AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}} where S&lt;:Union{FullSystem, TotalAngularMomentumSubSystem}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(::Tuple{S,S},
               a::SpinOrbital{&lt;:Orbital},
               X::TensorScalarProduct,
               b::SpinOrbital{&lt;:Orbital}) where {S&lt;:Union{FullSystem,TotalAngularMomentumSubSystem}}</code></pre><p>The matrix element of a tensor scalar product, where both factors act on the full system or the total angular momentum, evaluated in the basis of uncoupled spin-orbitals, is computed by transforming to the coupled system via <span>$\eqref{eqn:coupling}$</span>, which then dispatches to <span>$\eqref{eqn:scalar-product-tensor-matrix-element}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L897-L908">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}} where S&lt;:SubSystem" href="#AngularMomentumAlgebra.matrix_element-Union{Tuple{S}, Tuple{Tuple{S, S}, SpinOrbital{var&quot;#s10&quot;, M} where {var&quot;#s10&quot;&lt;:Orbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s9&quot;, M} where {var&quot;#s9&quot;&lt;:Orbital, M&lt;:Tuple}}} where S&lt;:SubSystem"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element(systems::Tuple{S,S},
               a::SpinOrbital{&lt;:Orbital},
               X::TensorScalarProduct,
               b::SpinOrbital{&lt;:Orbital}) where {S&lt;:SubSystem}</code></pre><p>The matrix element of a tensor scalar product, where both factors act on the same subsystem, evaluated in the basis of uncoupled spin-orbitals, is just a special case of <span>$\eqref{eqn:tensor-matrix-element-subsystem-uncoupled}$</span> combined with <span>$\eqref{eqn:scalar-product-tensor-matrix-element}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L916-L927">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Tuple{SubSystem, SubSystem}, SpinOrbital{var&quot;#s8&quot;, M} where {var&quot;#s8&quot;&lt;:Orbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s7&quot;, M} where {var&quot;#s7&quot;&lt;:Orbital, M&lt;:Tuple}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Tuple{SubSystem, SubSystem}, SpinOrbital{var&quot;#s8&quot;, M} where {var&quot;#s8&quot;&lt;:Orbital, M&lt;:Tuple}, TensorScalarProduct, SpinOrbital{var&quot;#s7&quot;, M} where {var&quot;#s7&quot;&lt;:Orbital, M&lt;:Tuple}}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((sâ‚,sâ‚‚)::Tuple{&lt;:SubSystem,&lt;:SubSystem},
               a::SpinOrbital{&lt;:Orbital},
               X::TensorScalarProduct,
               b::SpinOrbital{&lt;:Orbital})</code></pre><p>The matrix element of a tensor scalar product, where the factors act on different subsystems, evaluated in the basis of uncoupled spin-orbitals, is computed using <span>$\eqref{eqn:scalar-product-tensor-matrix-element-diff-coords-uncoupled}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L937-L947">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Tuple{AngularMomentumAlgebra.System, AngularMomentumAlgebra.System}, Tuple{SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:Orbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:Orbital, M&lt;:Tuple}}, TensorScalarProduct, Tuple{SpinOrbital{var&quot;#s2&quot;, M} where {var&quot;#s2&quot;&lt;:Orbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s1&quot;, M} where {var&quot;#s1&quot;&lt;:Orbital, M&lt;:Tuple}}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Tuple{AngularMomentumAlgebra.System, AngularMomentumAlgebra.System}, Tuple{SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:Orbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:Orbital, M&lt;:Tuple}}, TensorScalarProduct, Tuple{SpinOrbital{var&quot;#s2&quot;, M} where {var&quot;#s2&quot;&lt;:Orbital, M&lt;:Tuple}, SpinOrbital{var&quot;#s1&quot;, M} where {var&quot;#s1&quot;&lt;:Orbital, M&lt;:Tuple}}}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((sâ‚,sâ‚‚)::Tuple{&lt;:System,&lt;:System},
               (a,b)::Tuple{&lt;:SpinOrbital{&lt;:Orbital},
                            &lt;:SpinOrbital{&lt;:Orbital}},
               X::TensorScalarProduct,
               (c,d)::Tuple{&lt;:SpinOrbital{&lt;:Orbital},
                            &lt;:SpinOrbital{&lt;:Orbital}})</code></pre><p>The matrix element of a tensor scalar product, where the factors act on the orbital pairs <code>a</code>,<code>c</code> and <code>b</code>,<code>d</code>, respectively, evaluated in the basis of uncoupled spin-orbitals, is computed using <span>$\eqref{eqn:scalar-product-tensor-matrix-element-diff-coords-uncoupled}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L957-L969">source</a></section></article><h2 id="Tensor-acts-on-entire-system"><a class="docs-heading-anchor" href="#Tensor-acts-on-entire-system">Tensor acts on entire system</a><a id="Tensor-acts-on-entire-system-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-acts-on-entire-system" title="Permalink"></a></h2><h3 id="wigner_eckart"><a class="docs-heading-anchor" href="#wigner_eckart">The Wignerâ€“Eckart theorem</a><a id="wigner_eckart-1"></a><a class="docs-heading-anchor-permalink" href="#wigner_eckart" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Tuple{Any, Number}, TensorComponent, Tuple{Any, Number}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Tuple{Any, Number}, TensorComponent, Tuple{Any, Number}}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((Î³jâ€², mâ€²), Táµq::TensorComponent, (Î³j, m))</code></pre><p>Calculate the matrix element <code>âŸ¨Î³â€²jâ€²mâ€²|Táµq|Î³jmâŸ©</code> via Wignerâ€“Eckart&#39;s theorem:</p><p class="math-container">\[\begin{equation}
\begin{aligned}
\matrixel{\gamma&#39;j&#39;m&#39;}{\tensor{T}^{(k)}_q}{\gamma jm}
&amp;\defd
(-)^{2k} \frac{1}{\angroot{j&#39;}}
C_{jm;kq}^{j&#39;m&#39;}
\redmatrixel{\gamma&#39; j&#39;}{\tensor{T}^{(k)}}{\gamma j} \\
&amp;=
(-)^{j&#39;-m&#39;}
\begin{pmatrix}
j&#39;&amp;k&amp;j\\
-m&#39;&amp;q&amp;m
\end{pmatrix}
\redmatrixel{\gamma&#39;j&#39;}{\tensor{T}^{(k)}}{\gamma j},
\end{aligned}
\label{eqn:wigner-eckart}
\tag{V13.1.2}
\end{equation}\]</p><p>where the <em>reduced matrix element</em> <span>$\redmatrixel{n&#39;j&#39;}{\tensor{T}^{(k)}}{nj}$</span> does not depend on <span>$m,m&#39;$</span>. <code>jâ€²</code> and <code>j</code> are the total angular momenta with <code>mâ€²</code> and <code>m</code> being their respective projections. <code>Î³â€²</code> and <code>Î³</code> are all other quantum numbers needed to fully specify the quantum system; their presence depend on the quantum system.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix_element((2, 1), TensorComponent(OrbitalAngularMomentum(), 1), (2, 0))
-1.7320508075688774

julia&gt; matrix_element((0, 0), TensorComponent(SphericalTensor(1), 0), (1, 0))
0.5773502691896256

julia&gt; matrix_element(((1,half(1),half(1)), -half(1)),
                     TensorComponent(TotalAngularMomentum(), -1),
                     ((1,half(1),half(1)), half(1)))
0.7071067811865475</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L4-L53">source</a></section></article><h3 id="Product-tensors"><a class="docs-heading-anchor" href="#Product-tensors">Product tensors</a><a id="Product-tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Product-tensors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Any, TensorScalarProduct, Any}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Any, TensorScalarProduct, Any}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((Î³jâ€², mâ€²), X::TensorScalarProduct, (Î³j, m))</code></pre><p>Calculate the matrix element of a scalar product tensor according to:</p><p class="math-container">\[\begin{equation}
\begin{aligned}
\matrixel{n&#39;j&#39;m&#39;}{[\tensor{P}^{(k)}\cdot\tensor{Q}^{(k)}]}{njm}
=&amp;
\delta_{jj&#39;}\delta_{mm&#39;}
\frac{1}{\angroot{j}^2}\\
&amp;\times\sum_{n_1j_1}
(-)^{-j+j_1}
\redmatrixel{n&#39;j}{\tensor{P}^{(k)}}{n_1j_1}
\redmatrixel{n_1j_1}{\tensor{Q}^{(k)}}{nj}
\end{aligned}
\label{eqn:scalar-product-tensor-matrix-element}
\tag{V13.1.11}
\end{equation}\]</p><p>The permissible values of <span>$n_1j_1$</span> in the summation are found using <a href="../angular_momenta/#AngularMomentumAlgebra.couplings-Tuple{OrbitalAngularMomentum, Any}"><code>AngularMomentumAlgebra.couplings</code></a>; it is assumed that the summation only consists of a finite amount of terms and that</p><p class="math-container">\[\redmatrixel{n&#39;j}{\tensor{P}^{(k)}}{n_1j_1}\neq0
\iff
\redmatrixel{n_1j_1}{\tensor{P}^{(k)}}{n&#39;j}\neq0,\]</p><p>i.e. that <span>$\tensor{P}^{(k)}$</span> is (skew)symmetric.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ğ’ = SpinAngularMomentum()
ğ’Ì‚â½Â¹â¾

julia&gt; ğ’Â² = ğ’â‹…ğ’
(ğ’Ì‚â½Â¹â¾â‹…ğ’Ì‚â½Â¹â¾)

julia&gt; matrix_element((half(1), half(1)),
                      ğ’Â², (half(1), half(1)))
0.7499999999999998

julia&gt; half(1)*(half(1)+1) # S(S+1)
0.75

julia&gt; ğ‰ = TotalAngularMomentum()
ğ‰Ì‚â½Â¹â¾

julia&gt; ğ‰Â² = ğ‰â‹…ğ‰
(ğ‰Ì‚â½Â¹â¾â‹…ğ‰Ì‚â½Â¹â¾)

julia&gt; matrix_element(((1, half(1), half(3)), half(3)),
                      ğ‰Â², ((1, half(1), half(3)), half(3)))
3.7500000000000004

julia&gt; half(3)*(half(3)+1) # J(J+1)
3.75</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L74-L137">source</a></section></article><h3 id="Uncoupled-basis-functions"><a class="docs-heading-anchor" href="#Uncoupled-basis-functions">Uncoupled basis functions</a><a id="Uncoupled-basis-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Uncoupled-basis-functions" title="Permalink"></a></h3><p>For a tensor operator that depends on all coordinates, its matrix element in the uncoupled basis are computed via a basis transform to the coupled basis:</p><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-NTuple{5, Any}" href="#AngularMomentumAlgebra.matrix_element-NTuple{5, Any}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((Î³jâ‚â€², mâ‚â€²), (Î³jâ‚‚â€², mâ‚‚â€²), ğ“áµq, (Î³jâ‚, mâ‚), (Î³jâ‚‚, mâ‚‚))</code></pre><p>Compute the matrix element of the irreducible tensor <code>ğ“áµq</code> acting on coordinates <code>1</code> and <code>2</code>, by first coupling <code>Î³jâ‚â€²mâ‚â€²Î³jâ‚‚â€²mâ‚‚â€²</code> and <code>Î³jâ‚mâ‚Î³jâ‚‚mâ‚‚</code> to all permissible <code>jâ€²mâ€²</code> and <code>jm</code>, respectively, according to</p><p class="math-container">\[\begin{equation}
\begin{aligned}
&amp;\matrixel{Î³_1&#39;j_1&#39;m_1&#39;;Î³_2&#39;j_2&#39;m_2&#39;}{\tensor{P}^{(k)}_q(1,2)}{Î³_1j_1m_1;Î³_2j_2m_2} \\
=&amp; (-)^{2k}
\frac{1}{\angroot{j&#39;}}
\sum_{jmj&#39;m&#39;}
C_{j_1m_1;j_2m_2}^{jm}
C_{j_1&#39;m_1&#39;;j_2&#39;m_2&#39;}^{j&#39;m&#39;}
C_{jm;kq}^{j&#39;m&#39;}\\
&amp;\times
\redmatrixel{Î³_1&#39;j_1&#39;Î³_2&#39;j_2&#39;j&#39;}{\tensor{P}^{(k)}(1,2)}{Î³_1j_1Î³_2j_2j} \\
\equiv&amp;
\sum_{jmj&#39;m&#39;}
C_{j_1m_1;j_2m_2}^{jm}
C_{j_1&#39;m_1&#39;;j_2&#39;m_2&#39;}^{j&#39;m&#39;}
\matrixel{Î³_1&#39;j_1&#39;Î³_2&#39;j_2&#39;j&#39;m&#39;}{\tensor{P}^{(k)}(1,2)}{Î³_1j_1Î³_2j_2jm}
\end{aligned}
\tag{V13.1.23}
\label{eqn:coupling}
\end{equation}\]</p><p>The non-vanishing terms of the sum are found using <a href="../angular_momenta/#AngularMomentumAlgebra.couplings-Tuple{OrbitalAngularMomentum, Any}"><code>AngularMomentumAlgebra.couplings</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ğ‰ = TotalAngularMomentum()
ğ‰Ì‚â½Â¹â¾

julia&gt; ğ‰â‚€ = TensorComponent(ğ‰, 0)
ğ‰Ì‚â½Â¹â¾â‚€

julia&gt; matrix_element((1,1), (half(1),half(1)),
                      ğ‰â‚€, (1,1), (half(1), half(1)))
1.5

julia&gt; matrix_element((1,-1), (half(1),half(1)),
                      ğ‰â‚€, (1,-1), (half(1), half(1)))
-0.4999999999999999

julia&gt; ğ‰â‚ = TensorComponent(ğ‰, 1)
ğ‰Ì‚â½Â¹â¾â‚

julia&gt; matrix_element((1,1), (half(1),half(1)),
                      ğ‰â‚, (1,0), (half(1), half(1)))
-1.0

julia&gt; ğ‰Â² = ğ‰â‹…ğ‰
(ğ‰Ì‚â½Â¹â¾â‹…ğ‰Ì‚â½Â¹â¾)

julia&gt; matrix_element((1,1), (half(1),half(1)),
                      ğ‰Â², (1,1), (half(1), half(1)))
3.7500000000000004

julia&gt; half(3)*(half(3)+1) # J(J+1)
3.75</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L161-L229">source</a></section></article><h2 id="Tensor-acts-on-subsystems"><a class="docs-heading-anchor" href="#Tensor-acts-on-subsystems">Tensor acts on subsystems</a><a id="Tensor-acts-on-subsystems-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-acts-on-subsystems" title="Permalink"></a></h2><h3 id="Uncoupling"><a class="docs-heading-anchor" href="#Uncoupling">Uncoupling</a><a id="Uncoupling-1"></a><a class="docs-heading-anchor-permalink" href="#Uncoupling" title="Permalink"></a></h3><p>When the tensor operator is reducible and only acts on one part of the quantum system, in the coupled basis we employ the following uncoupling formula:</p><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element-Tuple{Tuple{Any, Any, Number, Number}, TensorComponent, Tuple{Any, Any, Number, Number}}" href="#AngularMomentumAlgebra.matrix_element-Tuple{Tuple{Any, Any, Number, Number}, TensorComponent, Tuple{Any, Any, Number, Number}}"><code>AngularMomentumAlgebra.matrix_element</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element((Î³jâ‚â€², Î³jâ‚‚â€², jâ€², mâ€²), ğ“áµq, (Î³jâ‚, Î³jâ‚‚, j, m))</code></pre><p>Compute the matrix element of the tensor <code>ğ“áµq</code> which acts on coordinate <code>1</code> only in the coupled basis, by employing the uncoupling formula</p><p class="math-container">\[\begin{equation}
\begin{aligned}
&amp;\matrixel{Î³_1&#39;j_1&#39;Î³_2&#39;j_2&#39;j&#39;m&#39;}{\tensor{T}^{(k)}_q(1)}{Î³_1j_1Î³_2j_2jm}\\
=&amp; \delta_{j_2&#39;j_2}\delta_{Î³_2&#39;Î³_2}
(-)^{j+j_1&#39;+j_2-k}
\angroot{j}
C_{jm;kq}^{j&#39;m&#39;}\\
&amp;\times
\wignersixj{j_1&amp;j_2&amp;j\\j&#39;&amp;k&amp;j_1&#39;}
\redmatrixel{Î³_1&#39;j_1&#39;}{\tensor{T}^{(k)}(1)}{Î³_1j_1}
\end{aligned}
\tag{V13.1.40}
\label{eqn:uncoupling}
\end{equation}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ğ‹â‚€ = TensorComponent(OrbitalAngularMomentum(), 0)
ğ‹Ì‚â½Â¹â¾â‚€

julia&gt; matrix_element((1, half(1), half(3), half(3)),
                      ğ‹â‚€, (1, half(1), half(3), half(3)))
0.9999999999999999

julia&gt; matrix_element((1, 1), ğ‹â‚€, (1, 1)) # For comparison
0.9999999999999999

julia&gt; ğ’â‚€ = TensorComponent(SpinAngularMomentum(), 0)
ğ’Ì‚â½Â¹â¾â‚€

julia&gt; matrix_element((half(1), 1, half(3), half(3)),
                      ğ’â‚€, (half(1), 1, half(3), half(3)))
0.49999999999999994

julia&gt; matrix_element((half(1),half(1)), ğ’â‚€, (half(1),half(1)))
0.49999999999999994</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L255-L303">source</a></section></article><h3 id="Evaluation-in-subspace"><a class="docs-heading-anchor" href="#Evaluation-in-subspace">Evaluation in subspace</a><a id="Evaluation-in-subspace-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-in-subspace" title="Permalink"></a></h3><p>In the uncoupled basis, the matrix element of a tensor operator acting only on a subsystem is simply given by the appropriate <a href="#AngularMomentumAlgebra.matrix_element-Tuple{Union{FullSystem, TotalAngularMomentumSubSystem}, SpinOrbital{var&quot;#s6&quot;, M} where {var&quot;#s6&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}, TensorComponent, SpinOrbital{var&quot;#s5&quot;, M} where {var&quot;#s5&quot;&lt;:RelativisticOrbital, M&lt;:Tuple}}"><code>matrix_element</code></a> applied to the quantum numbers characterizing the subspace, with the extra diagonality constraint for the <a href="../orbitals/#AngularMomentumAlgebra.other_quantum_numbers"><code>other_quantum_numbers</code></a> enforced using <a href="../common/#AngularMomentumAlgebra.@Î´"><code>AngularMomentumAlgebra.@Î´</code></a>.</p><h3 id="Product-tensors-2"><a class="docs-heading-anchor" href="#Product-tensors-2">Product tensors</a><a class="docs-heading-anchor-permalink" href="#Product-tensors-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element2-Tuple{Any, Any, TensorScalarProduct, Any, Any}" href="#AngularMomentumAlgebra.matrix_element2-Tuple{Any, Any, TensorScalarProduct, Any, Any}"><code>AngularMomentumAlgebra.matrix_element2</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element2(Î³jmâ‚â€², Î³jmâ‚‚â€², X::TensorScalarProduct, Î³jmâ‚, Î³jmâ‚‚)</code></pre><p>The matrix element of a scalar product of two tensors acting on different coordinates is given by (in the uncoupled basis)</p><p class="math-container">\[\begin{equation}
\begin{aligned}
&amp;\matrixel{\gamma_1&#39;j_1&#39;m_1&#39;;\gamma_2&#39;j_2&#39;m_2&#39;}{[\tensor{P}^{(k)}(1)\cdot\tensor{Q}^{(k)}(2)]}{\gamma_1j_1m_1;\gamma_2j_2m_2}\\
=&amp;
\frac{1}{\angroot{j_1&#39;j_2&#39;}}
\sum_\alpha(-)^{-\alpha}
C_{j_1m_1;k,\alpha}^{j_1&#39;m_1&#39;}
C_{j_2m_2;k,-\alpha}^{j_2&#39;m_2&#39;}\\
&amp;\times
\redmatrixel{\gamma_1&#39;j_1&#39;}{\tensor{P}^{(k)}(1)}{\gamma_1j_1}
\redmatrixel{\gamma_2&#39;j_2&#39;}{\tensor{Q}^{(k)}(2)}{\gamma_2j_2} \\
\equiv&amp;
\sum_\alpha
(-)^{-\alpha}
\matrixel{\gamma_1&#39;j_1&#39;m_1&#39;}{\tensor{P}^{(k)}_{\alpha}(1)}{\gamma_1j_1m_1}
\matrixel{\gamma_2&#39;j_2&#39;m_2&#39;}{\tensor{Q}^{(k)}_{-\alpha}(2)}{\gamma_2j_2m_2}
\end{aligned}
\tag{V13.1.26}
\label{eqn:scalar-product-tensor-matrix-element-diff-coords-uncoupled}
\end{equation}\]</p><p>Since the <a href="../definitions/#Clebschâ€“Gordan-coefficients">Clebschâ€“Gordan coefficients</a> can be rewritten using 3j symbols and the 3j symbols vanish unless <span>$m_1 + \alpha - m_1&#39; = m_2 - \alpha - m_2&#39; = 0$</span>, we have</p><p class="math-container">\[\alpha = m_1&#39; - m_1 = m_2-m_2&#39;\]</p><p>This case occurs in two-body interactions, such as the <a href="../coulomb/#Coulomb-interaction">Coulomb interaction</a>, where <span>$1&#39;,1$</span> and <span>$2&#39;,2$</span> are pairs of orbitals and the scalar product tensor is a term in the multipole expansion in terms of <a href="../spherical_tensors/#tensors_spherical_tensors">Spherical tensors</a>:</p><pre><code class="language-julia-repl hljs">julia&gt; ğ‚â° = SphericalTensor(0)
ğ‚Ì‚â½â°â¾

julia&gt; matrix_element2((0, 0), (0, 0), ğ‚â°â‹…ğ‚â°, (0,0), (0, 0)) # âŸ¨1sâ‚€,1sâ‚€|ğ‚â°â‹…ğ‚â°|1sâ‚€,1sâ‚€âŸ©
1.0

julia&gt; ğ‚Â¹ = SphericalTensor(1)
ğ‚Ì‚â½Â¹â¾

julia&gt; matrix_element2((0, 0), (1, 0), ğ‚Â¹â‹…ğ‚Â¹, (1,0), (2, 0)) # âŸ¨1sâ‚€,2pâ‚€|ğ‚Â¹â‹…ğ‚Â¹|2pâ‚€,3dâ‚€âŸ©
0.29814239699997186

julia&gt; matrix_element2((0, 0), (1, 1), ğ‚Â¹â‹…ğ‚Â¹, (1,0), (2, 1)) # âŸ¨1sâ‚€,2pâ‚|ğ‚Â¹â‹…ğ‚Â¹|2pâ‚€,3dâ‚âŸ©
0.25819888974716104</code></pre><p>but also in the case of the operator <span>$\tensor{L}\cdot\tensor{S}$</span> and coordinates <span>$1$</span> and <span>$2$</span> correspond to orbital and spin angular momenta, respectively. We can verify this using the classical result known from spinâ€“orbit splitting:</p><p class="math-container">\[\begin{aligned}
J^2 &amp;= (\tensor{L}+\tensor{S})^2 = L^2 + 2\tensor{L}\cdot\tensor{S} + S^2\\
\implies
\expect{\tensor{L}\cdot\tensor{S}} &amp;=
\frac{1}{2}(\expect{J^2} - \expect{L^2} - \expect{S^2}) =
\frac{1}{2}[J(J+1) - L(L+1) - S(S+1)]
\end{aligned}\]</p><p>In the uncoupled basis, <span>$J$</span> is not a good quantum number (it is not a constant of motion), except for <em>pure states</em>, i.e. those with maximal <span>$\abs{m_\ell + m_s}$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; X = OrbitalAngularMomentum()â‹…SpinAngularMomentum()
(ğ‹Ì‚â½Â¹â¾â‹…ğ’Ì‚â½Â¹â¾)

julia&gt; matrix_element2((1, 1), (half(1), half(1)),
                      X, (1,1), (half(1), half(1)))
0.4999999999999999

julia&gt; 1/2*(half(3)*(half(3)+1)-1*(1+1)-half(1)*(half(1)+1)) # 1/2(J(J+1)-L(L+1)-S(S+1))
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L357-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AngularMomentumAlgebra.matrix_element2-Tuple{Any, TensorScalarProduct, Any}" href="#AngularMomentumAlgebra.matrix_element2-Tuple{Any, TensorScalarProduct, Any}"><code>AngularMomentumAlgebra.matrix_element2</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_element2((Î³jâ‚â€², Î³jâ‚‚â€², jâ€², mâ€²), X::TensorScalarProduct, (Î³jâ‚, Î³jâ‚‚, j, m))</code></pre><p>The matrix element of a scalar product of two tensors acting on different coordinates is given by (in the coupled basis)</p><p class="math-container">\[\begin{equation}
\begin{aligned}
&amp;\matrixel{n_1&#39;j_1&#39;n_2&#39;j_2&#39;j&#39;m&#39;}{[\tensor{P}^{(k)}(1)\cdot\tensor{Q}^{(k)}(2)]}{n_1j_1n_2j_2jm}\\
=&amp; \delta_{j&#39;j}\delta_{m&#39;m}
(-)^{j+j_1+j_2&#39;}
\wignersixj{j_1&#39;&amp;j_1&amp;k\\j_2&amp;j_2&#39;&amp;j}\\
&amp;\times
\redmatrixel{n_1&#39;j_1&#39;}{\tensor{P}^{(k)}(1)}{n_1j_1}
\redmatrixel{n_2&#39;j_2&#39;}{\tensor{Q}^{(k)}(2)}{n_2j_2}.
\end{aligned}
\tag{V13.1.29}
\label{eqn:scalar-product-tensor-matrix-element-diff-coords-coupled}
\end{equation}\]</p><pre><code class="language-julia-repl hljs">julia&gt; X = OrbitalAngularMomentum()â‹…SpinAngularMomentum()
(ğ‹Ì‚â½Â¹â¾â‹…ğ’Ì‚â½Â¹â¾)

julia&gt; matrix_element2((1, half(1), half(3), half(3)),
                       X, (1, half(1), half(3), half(3)))
0.4999999999999999</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/AngularMomentumAlgebra.jl/blob/ad999b16071149d218f733f323f240673aa0d683/src/tensor_matrix_elements.jl#L459-L489">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../coulomb/">Â« Coulomb interaction</a><a class="docs-footer-nextpage" href="../energy_expressions/">Energy expressions Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Tuesday 8 November 2022 17:02">Tuesday 8 November 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
